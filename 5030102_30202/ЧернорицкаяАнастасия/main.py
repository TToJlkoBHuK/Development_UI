from __future__ import annotations

from enum import Enum
from typing import List, Iterator, Optional


class ТипЯчеекРемесло(Enum):
    Пол = "Пол"
    Оборуд = "Оборуд"
    Починено = "Починено"
    Запчасть = "Запчасть"
    Барьер = "Барьер"
    Финиш = "Финиш"
    Склад = "Склад"


class ТипНаправленийТехНапр(Enum):
    ТехВперед = "ТехВперед"
    ТехНазад = "ТехНазад"
    ТехЛево = "ТехЛево"
    ТехПраво = "ТехПраво"
    ДиагТВ = "ДиагТВ"
    ДиагТН = "ДиагТН"


class БазовыеТипыНаправления(Enum):
    C = "C"
    Ю = "Ю"
    З = "З"
    В = "В"
    СЗ = "СЗ"
    ЮВ = "ЮВ"

СТОРОНА_В_НАПРАВЛЕНИЕ = {
    БазовыеТипыНаправления.C: ТипНаправленийТехНапр.ТехВперед,
    БазовыеТипыНаправления.Ю: ТипНаправленийТехНапр.ТехНазад,
    БазовыеТипыНаправления.З: ТипНаправленийТехНапр.ТехЛево,
    БазовыеТипыНаправления.В: ТипНаправленийТехНапр.ТехПраво,
    БазовыеТипыНаправления.СЗ: ТипНаправленийТехНапр.ДиагТВ,
    БазовыеТипыНаправления.ЮВ: ТипНаправленийТехНапр.ДиагТН,
}


class ЯчейкаРоботТехник:

    def __init__(
        self,
        тип_ячейки: Optional[ТипЯчеекРемесло] = None,
        ячейка_робота: bool = False,
        x: int = 0,
        y: int = 0,
    ) -> None:
        self.ячейка_робота: bool = ячейка_робота
        self.тип_ячейки: Optional[ТипЯчеекРемесло] = тип_ячейки
        self.x: int = x
        self.y: int = y

    def __repr__(self) -> str:
        return (
            f"ЯчейкаРоботТехник("
            f"type={self.тип_ячейки}, robot={self.ячейка_робота}, "
            f"x={self.x}, y={self.y})"
        )


class ЛабиринтРоботТехник:
    def __init__(
        self,
        ширина: int = 0,
        длина: int = 0,
        ячейки: Optional[List[List[ЯчейкаРоботТехник]]] = None,
    ) -> None:
        self.ширина: int = ширина
        self.длина: int = длина
        self.ячейки: List[List[ЯчейкаРоботТехник]] = ячейки or []

    def УстановитьКоординаты(self) -> None:
        for y, row in enumerate(self.ячейки):
            for x, cell in enumerate(row):
                cell.x = x
                cell.y = y

    def ПолучитьСоседнююЯчейку(
        self,
        текущая_ячейка: ЯчейкаРоботТехник,
        направление_поиска: ТипНаправленийТехНапр,
    ) -> Optional[ЯчейкаРоботТехник]:
        if текущая_ячейка is None:
            return None

        if not self.ячейки:
            return None

        if направление_поиска == ТипНаправленийТехНапр.ТехВперед:
            dx, dy = (0, 1)
        elif направление_поиска == ТипНаправленийТехНапр.ТехНазад:
            dx, dy = (0, -1)
        elif направление_поиска == ТипНаправленийТехНапр.ТехЛево:
            dx, dy = (-1, 0)
        elif направление_поиска == ТипНаправленийТехНапр.ТехПраво:
            dx, dy = (1, 0)
        elif направление_поиска == ТипНаправленийТехНапр.ДиагТВ:
            dx, dy = (-1, 1)
        elif направление_поиска == ТипНаправленийТехНапр.ДиагТН:
            dx, dy = (1, -1)
        else:
            return None

        nx = текущая_ячейка.x + dx
        ny = текущая_ячейка.y + dy

        if not (0 <= nx < self.ширина and 0 <= ny < self.длина):
            return None

        соседняя = self.ячейки[ny][nx]
        # на барьер и склад нельзя заходить
        if соседняя.тип_ячейки in (
            ТипЯчеекРемесло.Барьер,
            ТипЯчеекРемесло.Склад,
        ):
            return None

        return соседняя

    def ПолучитьИтератор(self) -> Iterator[ЯчейкаРоботТехник]:
        if not self.ячейки:
            return iter(())

        self.УстановитьКоординаты()

        width = self.ширина
        height = self.длина

        x = 0
        y = 0
        direction = 1

        while True:
            yield self.ячейки[y][x]

            if direction == 1:  # движемся вправо
                if x == width - 1:
                    if y == height - 1:
                        break  # достигнут верхний ряд
                    y += 1
                    direction = -1
                else:
                    x += 1
            else:  # движемся влево
                if x == 0:
                    if y == height - 1:
                        break
                    y += 1
                    direction = 1
                else:
                    x -= 1

    def ИнициализироватьЛабиринт(
        self,
        тип_ячейки: ТипЯчеекРемесло,
        ширина: Optional[int] = None,
        длина: Optional[int] = None,
    ) -> None:
        if ширина is not None:
            self.ширина = ширина
        if длина is not None:
            self.длина = длина

        if self.ширина <= 0 or self.длина <= 0:
            self.ячейки = []
            return

        self.ячейки = []
        for y in range(self.длина):
            row: List[ЯчейкаРоботТехник] = []
            for x in range(self.ширина):
                row.append(ЯчейкаРоботТехник(тип_ячейки=тип_ячейки, x=x, y=y))
            self.ячейки.append(row)


class РоботТехник:
    def __init__(self, лабиринт: Optional[ЛабиринтРоботТехник] = None) -> None:
        self.лабиринт: Optional[ЛабиринтРоботТехник] = лабиринт
        self.текущая_ячейка: Optional[ЯчейкаРоботТехник] = None

        if лабиринт is not None and лабиринт.ячейки:
            for row in лабиринт.ячейки:
                for cell in row:
                    if cell.ячейка_робота:
                        self.текущая_ячейка = cell
                        break



    def УстановитьТекущуюЯчейку(
        self, новая_ячейка: Optional[ЯчейкаРоботТехник]
    ) -> Optional[ЯчейкаРоботТехник]:
        if новая_ячейка is None:
            return None
        if self.текущая_ячейка is not None:
            self.текущая_ячейка.ячейка_робота = False
        self.текущая_ячейка = новая_ячейка
        self.текущая_ячейка.ячейка_робота = True
        return self.текущая_ячейка

    def Перейти(self, направление: ТипНаправленийТехНапр) -> Optional[ЯчейкаРоботТехник]:
        if self.лабиринт is None or self.текущая_ячейка is None:
            return None
        соседняя = self.лабиринт.ПолучитьСоседнююЯчейку(
            self.текущая_ячейка, направление
        )
        if соседняя is None:
            return None
        return self.УстановитьТекущуюЯчейку(соседняя)

    def ДвигТехВп(self) -> Optional[ЯчейкаРоботТехник]:
        return self.Перейти(ТипНаправленийТехНапр.ТехВперед)

    def ОтойтиТех(self) -> Optional[ЯчейкаРоботТехник]:
        return self.Перейти(ТипНаправленийТехНапр.ТехНазад)

    def СместитьсяЛево(self) -> Optional[ЯчейкаРоботТехник]:
        return self.Перейти(ТипНаправленийТехНапр.ТехЛево)

    def СместитьсяПраво(self) -> Optional[ЯчейкаРоботТехник]:
        return self.Перейти(ТипНаправленийТехНапр.ТехПраво)

    def Подняться(self) -> Optional[ЯчейкаРоботТехник]:
        return self.Перейти(ТипНаправленийТехНапр.ДиагТВ)

    def Спуститься(self) -> Optional[ЯчейкаРоботТехник]:
        return self.Перейти(ТипНаправленийТехНапр.ДиагТН)

    # Методы специализации:

    def Оборуд(self) -> None:
        if self.текущая_ячейка is None:
            return
        if self.текущая_ячейка.тип_ячейки == ТипЯчеекРемесло.Оборуд:
            self.текущая_ячейка.тип_ячейки = ТипЯчеекРемесло.Починено

    def Запчасть(self) -> None:
        if self.текущая_ячейка is None:
            return
        if self.текущая_ячейка.тип_ячейки == ТипЯчеекРемесло.Запчасть:
            self.текущая_ячейка.тип_ячейки = ТипЯчеекРемесло.Оборуд

    def ЗавершитьРаботу(self) -> bool:
        if self.текущая_ячейка is None:
            return False
        if self.текущая_ячейка.тип_ячейки != ТипЯчеекРемесло.Финиш:
            return False

        if self.лабиринт is None:
            return False

        for row in self.лабиринт.ячейки:
            for cell in row:
                if cell.тип_ячейки in (ТипЯчеекРемесло.Оборуд, ТипЯчеекРемесло.Запчасть):
                    return False

        return True
